// Source code is decompiled from a .class file using FernFlower decompiler.
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.Scanner;
import java.util.Set;

public class Main {
   static Scanner sc;
   static List<Process> processes;
   static int quantum;
   static final int MAX_QUEUE_LEVELS = 4;

   static {
      sc = new Scanner(System.in);
      processes = new ArrayList();
      quantum = 2;
   }

   public Main() {
   }

   public static void inputProcesses() {
      System.out.print("Enter number of processes: ");
      int n = sc.nextInt();
      processes.clear();

      for(int i = 0; i < n; ++i) {
         System.out.println("\nProcess P" + (i + 1));
         System.out.print("Arrival Time: ");
         int at = sc.nextInt();
         System.out.print("Burst Time: ");
         int bt = sc.nextInt();
         processes.add(new Process(i + 1, at, bt));
      }

   }

   public static void displayMetrics(List<Process> plist) {
      float totalTAT = 0.0F;
      float totalRT = 0.0F;
      System.out.println("\nPID\tAT\tBT\tCT\tTAT\tRT");
      Iterator var4 = plist.iterator();

      while(var4.hasNext()) {
         Process p = (Process)var4.next();
         p.turnaround = p.completion - p.arrival;
         p.response = p.started - p.arrival;
         totalTAT += (float)p.turnaround;
         totalRT += (float)p.response;
         System.out.printf("P%d\t%d\t%d\t%d\t%d\t%d\n", p.pid, p.arrival, p.burst, p.completion, p.turnaround, p.response);
      }

      System.out.printf("\nAverage Turnaround Time: %.2f\n", totalTAT / (float)plist.size());
      System.out.printf("Average Response Time: %.2f\n", totalRT / (float)plist.size());
   }

   public static void fcfs() {
      List<Process> plist = cloneProcesses();
      int time = 0;
      System.out.println("\nGantt Chart:");

      Process p;
      for(Iterator var3 = plist.iterator(); var3.hasNext(); p.completion = time) {
         p = (Process)var3.next();
         if (time < p.arrival) {
            time = p.arrival;
         }

         p.started = time;
         System.out.printf("| P%d (%d-%d) ", p.pid, time, time + p.burst);
         time += p.burst;
      }

      System.out.println("|");
      displayMetrics(plist);
   }

   public static void sjf() {
      List<Process> plist = cloneProcesses();
      int completed = 0;
      int time = 0;
      System.out.println("\nGantt Chart:");

      label44:
      while(completed < plist.size()) {
         Process shortest = null;
         Iterator var5 = plist.iterator();

         while(true) {
            Process p;
            do {
               do {
                  do {
                     if (!var5.hasNext()) {
                        if (shortest == null) {
                           ++time;
                        } else {
                           if (shortest.started == -1) {
                              shortest.started = time;
                           }

                           System.out.printf("| P%d (%d-%d) ", shortest.pid, time, time + shortest.burst);
                           time += shortest.burst;
                           shortest.remaining = 0;
                           shortest.completion = time;
                           ++completed;
                        }
                        continue label44;
                     }

                     p = (Process)var5.next();
                  } while(p.remaining <= 0);
               } while(p.arrival > time);
            } while(shortest != null && p.burst >= shortest.burst);

            shortest = p;
         }
      }

      System.out.println("|");
      displayMetrics(plist);
   }

   public static void srtf() {
      List<Process> plist = cloneProcesses();
      int completed = 0;
      int time = 0;
      System.out.println("\nGantt Chart:");

      label46:
      while(completed < plist.size()) {
         Process shortest = null;
         Iterator var5 = plist.iterator();

         while(true) {
            Process p;
            do {
               do {
                  do {
                     if (!var5.hasNext()) {
                        if (shortest == null) {
                           ++time;
                        } else {
                           if (shortest.started == -1) {
                              shortest.started = time;
                           }

                           System.out.printf("| P%d (%d-%d) ", shortest.pid, time, time + 1);
                           --shortest.remaining;
                           ++time;
                           if (shortest.remaining == 0) {
                              shortest.completion = time;
                              ++completed;
                           }
                        }
                        continue label46;
                     }

                     p = (Process)var5.next();
                  } while(p.remaining <= 0);
               } while(p.arrival > time);
            } while(shortest != null && p.remaining >= shortest.remaining);

            shortest = p;
         }
      }

      System.out.println("|");
      displayMetrics(plist);
   }

   public static void roundRobin() {
      List<Process> plist = cloneProcesses();
      Queue<Process> queue = new LinkedList();
      Set<Integer> visited = new HashSet();
      int time = 0;
      int completed = 0;
      queue.add((Process)plist.get(0));
      visited.add(((Process)plist.get(0)).pid);
      System.out.println("\nGantt Chart:");

      while(true) {
         while(completed < plist.size()) {
            Process current;
            if (queue.isEmpty()) {
               ++time;
               Iterator var9 = plist.iterator();

               while(var9.hasNext()) {
                  current = (Process)var9.next();
                  if (!visited.contains(current.pid) && current.arrival <= time) {
                     queue.add(current);
                     visited.add(current.pid);
                  }
               }
            } else {
               current = (Process)queue.poll();
               if (current.started == -1) {
                  current.started = time;
               }

               int slice = Math.min(quantum, current.remaining);
               System.out.printf("| P%d (%d-%d) ", current.pid, time, time + slice);
               time += slice;
               current.remaining -= slice;
               Iterator var8 = plist.iterator();

               while(var8.hasNext()) {
                  Process p = (Process)var8.next();
                  if (!visited.contains(p.pid) && p.arrival <= time) {
                     queue.add(p);
                     visited.add(p.pid);
                  }
               }

               if (current.remaining > 0) {
                  queue.add(current);
               } else {
                  current.completion = time;
                  ++completed;
               }
            }
         }

         System.out.println("|");
         displayMetrics(plist);
         return;
      }
   }

   public static void main(String[] args) {
      while(true) {
         System.out.println("\n=== CPU Scheduling Simulation ===");
         System.out.println("1. Enter Process Data");
         System.out.println("2. First Come First Serve (FCFS)");
         System.out.println("3. Shortest Job First (SJF)");
         System.out.println("4. Shortest Remaining Time First (SRTF)");
         System.out.println("5. Round Robin");
         System.out.println("6. Exit");
         System.out.print("Select an option: ");
         int choice = sc.nextInt();
         switch (choice) {
            case 1:
               inputProcesses();
               break;
            case 2:
               fcfs();
               break;
            case 3:
               sjf();
               break;
            case 4:
               srtf();
               break;
            case 5:
               System.out.print("Enter Time Quantum: ");
               quantum = sc.nextInt();
               roundRobin();
               break;
            case 6:
               System.exit(0);
               break;
            default:
               System.out.println("Invalid choice.");
         }
      }
   }

   private static List<Process> cloneProcesses() {
      List<Process> copy = new ArrayList();
      Iterator var2 = processes.iterator();

      while(var2.hasNext()) {
         Process p = (Process)var2.next();
         Process newP = new Process(p.pid, p.arrival, p.burst);
         copy.add(newP);
      }

      return copy;
   }
}
